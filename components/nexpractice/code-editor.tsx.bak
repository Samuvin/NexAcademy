"use client"

import { useEffect, useState, useRef } from "react"
import { javascript } from "@codemirror/lang-javascript"
import { cpp } from "@codemirror/lang-cpp"
import { java } from "@codemirror/lang-java"
import { python } from "@codemirror/lang-python"
import { EditorView, basicSetup } from "codemirror"
import { EditorState } from "@codemirror/state"
import { useTheme } from "next-themes"
import React from "react"
import { Settings, Undo, Check, Minus, Plus, ChevronDown, RefreshCw } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"
import { Separator } from "@/components/ui/separator"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip" 
import { createPortal } from "react-dom"
import { keymap } from "@codemirror/view"
import { indentUnit } from "@codemirror/language"
import { StateField, StateEffect, Range, RangeSet } from "@codemirror/state"
import { Decoration, DecorationSet } from "@codemirror/view"

interface CodeEditorProps {
  code: string
  setCode: (code: string) => void
  language: string
  preloadCode?: string // Original code for reset functionality
  initialShowSettings?: boolean // Initially show settings panel
  editorSettingsRef?: React.RefObject<{ showSettings: () => void } | null> // Ref to expose settings controls
  errorLine?: number | null // Add errorLine prop to highlight error lines
}

// Available themes
const editorThemes = {
  "system": "System Default",
  "light": "Light",
  "dark": "Dark",
  "dracula": "Dracula"
}

// Add/remove error line decorations
const addErrorLine = StateEffect.define<number>()
const clearErrorLines = StateEffect.define<null>()

// Create error line state field
const errorLineField = StateField.define<DecorationSet>({
  create() {
    return Decoration.none
  },
  update(value, tr) {
    value = value.map(tr.changes)
    
    for (let effect of tr.effects) {
      if (effect.is(addErrorLine)) {
        const line = effect.value
        const lines = tr.state.doc.lines
        
        if (line > 0 && line <= lines) {
          try {
            const lineObj = tr.state.doc.line(line)
            const decorations = []
            
            // Create error line decoration that preserves formatting
            decorations.push(
              Decoration.line({
                attributes: { 
                  class: "cm-error-line",
                  "data-error-line": line.toString() 
                }
              }).range(lineObj.from)
            )
            
            // Return a new decoration set
            return RangeSet.of(decorations);
          } catch (e) {
            console.error("Error applying error line decoration:", e);
            return value;
          }
        }
      } else if (effect.is(clearErrorLines)) {
        return Decoration.none
      }
    }
    
    return value
  },
  provide(field) {
    return EditorView.decorations.from(field)
  }
})

export function CodeEditor({ code, setCode, language, preloadCode, initialShowSettings = false, editorSettingsRef, errorLine = null }: CodeEditorProps) {
  const [element, setElement] = useState<HTMLElement | null>(null)
  const [editor, setEditor] = useState<EditorView | null>(null)
  const { resolvedTheme, setTheme } = useTheme()
  const isDark = resolvedTheme === "dark"
  const [mounted, setMounted] = useState(false)
  const isUserTyping = React.useRef(false)
  const lastDocContent = React.useRef(code)
  
  // Editor settings
  const [tabSize, setTabSize] = useState(4)
  const [fontSize, setFontSize] = useState(15)
  const [editorTheme, setEditorTheme] = useState<string>("system")
  const [showSettings, setShowSettings] = useState(initialShowSettings)
  const [themeDropdownOpen, setThemeDropdownOpen] = useState(false)

  // After mounting, we can safely use the theme
  useEffect(() => {
    setMounted(true)
  }, [])

  // Reset code to original
  const handleResetCode = () => {
    if (preloadCode) {
      setCode(preloadCode)
    }
  }

  // Update editor when settings change
  useEffect(() => {
    if (!element || !mounted || !editor) return
    
    // We need to recreate the editor when settings change
    recreateEditor()
  }, [tabSize, fontSize, editorTheme, resolvedTheme])

  // Create or recreate the editor
  const recreateEditor = () => {
    if (!element || !mounted) return

    // Clean up previous editor instance
    if (editor) {
      editor.destroy()
    }
    
    // Theme is now safe to use
    const isDarkMode = resolvedTheme === 'dark'
    const actualTheme = editorTheme === "system" ? resolvedTheme : editorTheme
    const isDarkTheme = actualTheme === "dark" || actualTheme === "dracula"

    const updateListener = EditorView.updateListener.of((update) => {
      if (update.docChanged) {
        isUserTyping.current = true
        lastDocContent.current = update.state.doc.toString()
        setCode(update.state.doc.toString())
        setTimeout(() => {
          isUserTyping.current = false
        }, 100)
      }
    })

    // Select language extension based on the language prop
    const getLangExtension = () => {
      switch (language) {
        case "JavaScript":
          return javascript()
        case "Python":
          return python()
        case "Java":
          return java()
        case "C++":
          return cpp()
        default:
          return javascript()
      }
    }

    // Get dracula theme styles
    const getDraculaTheme = () => {
      return {
        "&": {
          backgroundColor: "#282a36",
          color: "#f8f8f2",
        },
        ".cm-gutters": {
          backgroundColor: "#282a36",
          color: "#6272a4",
          border: "none",
        },
        ".cm-activeLineGutter": {
          backgroundColor: "#44475a",
        },
        ".cm-activeLine": {
          backgroundColor: "#44475a30",
        },
        ".cm-selectionMatch": {
          backgroundColor: "#6272a450",
        },
        ".cm-cursor": {
          borderLeftColor: "#f8f8f2",
        },
        ".cm-line": {
          color: "#f8f8f2",
        },
        ".cm-matchingBracket, .cm-nonmatchingBracket": {
          backgroundColor: "#44475a",
          color: "#f8f8f2",
        },
        // Syntax highlighting
        ".tok-keyword": { color: "#ff79c6" },
        ".tok-string, .tok-string2": { color: "#f1fa8c" },
        ".tok-comment": { color: "#6272a4", fontStyle: "italic" },
        ".tok-number": { color: "#bd93f9" },
        ".tok-property": { color: "#8be9fd" },
        ".tok-operator": { color: "#ff79c6" },
        ".tok-punctuation": { color: "#f8f8f2" },
        ".tok-variableName, .tok-propertyName": { color: "#50fa7b" },
        ".tok-typeName, .tok-namespace": { color: "#8be9fd" },
        ".tok-className": { color: "#8be9fd" },
        ".tok-functionName, .tok-macroName": { color: "#50fa7b" },
        // Add custom styling for error line
        ".cm-error-line": {
          backgroundColor: "rgba(255, 50, 50, 0.2) !important",
          position: "relative",
          left: "0 !important",
          textIndent: "0 !important",
        },
        // Add exclamation mark in gutter for error lines
        ".cm-error-line-gutter": {
          position: "relative",
          backgroundColor: "rgba(255, 50, 50, 0.1) !important",
        },
        ".cm-error-line-gutter::before": {
          content: '"!"',
          position: "absolute",
          right: "3px",
          top: "50%",
          transform: "translateY(-50%)",
          width: "16px",
          height: "16px", 
          backgroundColor: "#ff3333",
          color: "white",
          borderRadius: "50%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          fontSize: "12px",
          fontWeight: "bold",
          zIndex: 10,
          boxShadow: "0 0 2px rgba(0,0,0,0.3)",
        },
      }
    }

    const state = EditorState.create({
      doc: lastDocContent.current,
      extensions: [
        basicSetup,
        getLangExtension(),
        updateListener,
        EditorView.lineWrapping,
        EditorState.tabSize.of(tabSize),
        indentUnit.of(" ".repeat(tabSize)),
        errorLineField, // Add error line field
        keymap.of([
          {
            key: "Tab",
            preventDefault: true,
            run: (view) => {
              const tab = " ".repeat(tabSize)
              view.dispatch(view.state.replaceSelection(tab))
              return true
            },
            shift: (view) => {
              // Outdent logic (optional, can be improved)
              return false
            }
          }
        ]),
        EditorView.theme({
          "&": {
            height: "100%",
            fontSize: `${fontSize}px`,
            margin: 0,
            padding: 0,
            backgroundColor: actualTheme === "dracula" ? "#282a36" : 
                             isDarkTheme ? "#1e1e1e" : "white",
            color: actualTheme === "dracula" ? "#f8f8f2" : 
                   isDarkTheme ? "#d4d4d4" : "#333",
          },
          ".cm-scroller": {
            height: "100%",
            overflow: "auto",
            fontFamily: "'JetBrains Mono', monospace",
            padding: "0",
            /* VS Code scrollbar styling */
            "&::-webkit-scrollbar": {
              width: "8px",
              height: "8px",
            },
            "&::-webkit-scrollbar-track": {
              background: "transparent",
            },
            "&::-webkit-scrollbar-thumb": {
              background: isDarkTheme ? "rgba(150, 150, 150, 0.4)" : "rgba(100, 100, 100, 0.4)",
              borderRadius: "4px",
              "&:hover": {
                background: isDarkTheme ? "rgba(150, 150, 150, 0.7)" : "rgba(100, 100, 100, 0.7)",
              }
            },
            /* For Firefox */
            scrollbarWidth: "thin",
            scrollbarColor: isDarkTheme 
              ? "rgba(150, 150, 150, 0.4) transparent" 
              : "rgba(100, 100, 100, 0.4) transparent",
          },
          ".cm-gutters": {
            backgroundColor: actualTheme === "dracula" ? "#282a36" : 
                             isDarkTheme ? "#252526" : "#f8f9fa",
            color: actualTheme === "dracula" ? "#6272a4" :
                   isDarkTheme ? "#858585" : "#6c7086",
            border: "none",
            borderRight: actualTheme === "dracula" ? "1px solid #44475a" :
                          isDarkTheme ? "1px solid #333" : "1px solid #e5e7eb",
          },
          ".cm-activeLineGutter": {
            backgroundColor: actualTheme === "dracula" ? "#44475a" :
                              isDarkTheme ? "#2c2c2c" : "#f1f5f9",
          },
          ".cm-content": {
            padding: "0",
          },
          ".cm-line": {
            padding: "0 10px",
            lineHeight: "1.6",
          },
          ".cm-gutterElement": {
            padding: "0 10px 0 5px",
          },
          // Add Dracula theme specific styles if selected
          ...(actualTheme === "dracula" ? getDraculaTheme() : {})
        }),
      ],
    })

    const view = new EditorView({
      state,
      parent: element,
    })

    setEditor(view)
  }

  useEffect(() => {
    recreateEditor()

    return () => {
      if (editor) {
        editor.destroy()
      }
    }
  }, [element, language, mounted, setCode])

  // Update editor content when code prop changes (if different from current)
  useEffect(() => {
    // Only update the editor if the code prop changes from outside
    // and the user is not currently typing
    if (editor && 
        !isUserTyping.current && 
        lastDocContent.current !== code) {
      lastDocContent.current = code
      editor.dispatch({
        changes: {
          from: 0,
          to: editor.state.doc.length,
          insert: code,
        },
      })
    }
  }, [code, editor])
  
  // Handle error line highlighting
  useEffect(() => {
    if (!editor) return;
    
    // Debugging helper to log DOM structure
    const logEditorStructure = () => {
      try {
        const editorDOM = editor.dom;
        if (!editorDOM) {
          console.log("Editor DOM not available");
          return;
        }
        
        // Log the structure of lines and gutters
        const lines = editorDOM.querySelectorAll('.cm-line');
        const gutters = editorDOM.querySelectorAll('.cm-gutter');
        
        console.log(`Editor DOM structure: ${lines.length} lines, ${gutters.length} gutters`);
        console.log(`Target error line: ${errorLine}`);
      } catch (e) {
        console.error("Error logging editor structure:", e);
      }
    };
    
    // Function to clear all error highlights
    const clearAllErrorHighlights = () => {
      // Remove all existing error highlights
      document.querySelectorAll('.error-highlighted').forEach(el => {
        el.classList.remove('error-highlighted');
      });
"use client"

import { useEffect, useState, useRef } from "react"
import { javascript } from "@codemirror/lang-javascript"
import { cpp } from "@codemirror/lang-cpp"
import { java } from "@codemirror/lang-java"
import { python } from "@codemirror/lang-python"
import { EditorView, basicSetup } from "codemirror"
import { EditorState } from "@codemirror/state"
import { useTheme } from "next-themes"
import React from "react"
import { Settings, Undo, Check, Minus, Plus, ChevronDown, RefreshCw } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"
import { Separator } from "@/components/ui/separator"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip" 
import { createPortal } from "react-dom"
import { keymap } from "@codemirror/view"
import { indentUnit } from "@codemirror/language"
import { StateField, StateEffect, Range, RangeSet } from "@codemirror/state"
import { Decoration, DecorationSet } from "@codemirror/view"

interface CodeEditorProps {
  code: string
  setCode: (code: string) => void
  language: string
  preloadCode?: string // Original code for reset functionality
  initialShowSettings?: boolean // Initially show settings panel
  editorSettingsRef?: React.RefObject<{ showSettings: () => void } | null> // Ref to expose settings controls
  errorLine?: number | null // Add errorLine prop to highlight error lines
}

// Available themes
const editorThemes = {
  "system": "System Default",
  "light": "Light",
  "dark": "Dark",
  "dracula": "Dracula"
}

// Add/remove error line decorations
const addErrorLine = StateEffect.define<number>()
const clearErrorLines = StateEffect.define<null>()

// Create error line state field
const errorLineField = StateField.define<DecorationSet>({
  create() {
    return Decoration.none
  },
  update(value, tr) {
    value = value.map(tr.changes)
    
    for (let effect of tr.effects) {
      if (effect.is(addErrorLine)) {
        const line = effect.value
        const lines = tr.state.doc.lines
        
        if (line > 0 && line <= lines) {
          try {
            const lineObj = tr.state.doc.line(line)
            const decorations = []
            
            // Create error line decoration that preserves formatting
            decorations.push(
              Decoration.line({
                attributes: { 
                  class: "cm-error-line",
                  "data-error-line": line.toString() 
                }
              }).range(lineObj.from)
            )
            
            // Return a new decoration set
            return RangeSet.of(decorations);
          } catch (e) {
            console.error("Error applying error line decoration:", e);
            return value;
          }
        }
      } else if (effect.is(clearErrorLines)) {
        return Decoration.none
      }
    }
    
    return value
  },
  provide(field) {
    return EditorView.decorations.from(field)
  }
})

export function CodeEditor({ code, setCode, language, preloadCode, initialShowSettings = false, editorSettingsRef, errorLine = null }: CodeEditorProps) {
  const [element, setElement] = useState<HTMLElement | null>(null)
  const [editor, setEditor] = useState<EditorView | null>(null)
  const { resolvedTheme, setTheme } = useTheme()
  const isDark = resolvedTheme === "dark"
  const [mounted, setMounted] = useState(false)
  const isUserTyping = React.useRef(false)
  const lastDocContent = React.useRef(code)
  
  // Editor settings
  const [tabSize, setTabSize] = useState(4)
  const [fontSize, setFontSize] = useState(15)
  const [editorTheme, setEditorTheme] = useState<string>("system")
  const [showSettings, setShowSettings] = useState(initialShowSettings)
  const [themeDropdownOpen, setThemeDropdownOpen] = useState(false)

  // After mounting, we can safely use the theme
  useEffect(() => {
    setMounted(true)
  }, [])

  // Reset code to original
  const handleResetCode = () => {
    if (preloadCode) {
      setCode(preloadCode)
    }
  }

  // Update editor when settings change
  useEffect(() => {
    if (!element || !mounted || !editor) return
    
    // We need to recreate the editor when settings change
    recreateEditor()
  }, [tabSize, fontSize, editorTheme, resolvedTheme])

  // Create or recreate the editor
  const recreateEditor = () => {
    if (!element || !mounted) return

    // Clean up previous editor instance
    if (editor) {
      editor.destroy()
    }
    
    // Theme is now safe to use
    const isDarkMode = resolvedTheme === 'dark'
    const actualTheme = editorTheme === "system" ? resolvedTheme : editorTheme
    const isDarkTheme = actualTheme === "dark" || actualTheme === "dracula"

    const updateListener = EditorView.updateListener.of((update) => {
      if (update.docChanged) {
        isUserTyping.current = true
        lastDocContent.current = update.state.doc.toString()
        setCode(update.state.doc.toString())
        setTimeout(() => {
          isUserTyping.current = false
        }, 100)
      }
    })

    // Select language extension based on the language prop
    const getLangExtension = () => {
      switch (language) {
        case "JavaScript":
          return javascript()
        case "Python":
          return python()
        case "Java":
          return java()
        case "C++":
          return cpp()
        default:
          return javascript()
      }
    }

    // Get dracula theme styles
    const getDraculaTheme = () => {
      return {
        "&": {
          backgroundColor: "#282a36",
          color: "#f8f8f2",
        },
        ".cm-gutters": {
          backgroundColor: "#282a36",
          color: "#6272a4",
          border: "none",
        },
        ".cm-activeLineGutter": {
          backgroundColor: "#44475a",
        },
        ".cm-activeLine": {
          backgroundColor: "#44475a30",
        },
        ".cm-selectionMatch": {
          backgroundColor: "#6272a450",
        },
        ".cm-cursor": {
          borderLeftColor: "#f8f8f2",
        },
        ".cm-line": {
          color: "#f8f8f2",
        },
        ".cm-matchingBracket, .cm-nonmatchingBracket": {
          backgroundColor: "#44475a",
          color: "#f8f8f2",
        },
        // Syntax highlighting
        ".tok-keyword": { color: "#ff79c6" },
        ".tok-string, .tok-string2": { color: "#f1fa8c" },
        ".tok-comment": { color: "#6272a4", fontStyle: "italic" },
        ".tok-number": { color: "#bd93f9" },
        ".tok-property": { color: "#8be9fd" },
        ".tok-operator": { color: "#ff79c6" },
        ".tok-punctuation": { color: "#f8f8f2" },
        ".tok-variableName, .tok-propertyName": { color: "#50fa7b" },
        ".tok-typeName, .tok-namespace": { color: "#8be9fd" },
        ".tok-className": { color: "#8be9fd" },
        ".tok-functionName, .tok-macroName": { color: "#50fa7b" },
        // Add custom styling for error line
        ".cm-error-line": {
          backgroundColor: "rgba(255, 50, 50, 0.2) !important",
          position: "relative",
          left: "0 !important",
          textIndent: "0 !important",
        },
        // Add exclamation mark in gutter for error lines
        ".cm-error-line-gutter": {
          position: "relative",
          backgroundColor: "rgba(255, 50, 50, 0.1) !important",
        },
        ".cm-error-line-gutter::before": {
          content: '"!"',
          position: "absolute",
          right: "3px",
          top: "50%",
          transform: "translateY(-50%)",
          width: "16px",
          height: "16px", 
          backgroundColor: "#ff3333",
          color: "white",
          borderRadius: "50%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          fontSize: "12px",
          fontWeight: "bold",
          zIndex: 10,
          boxShadow: "0 0 2px rgba(0,0,0,0.3)",
        },
      }
    }

    const state = EditorState.create({
      doc: lastDocContent.current,
      extensions: [
        basicSetup,
        getLangExtension(),
        updateListener,
        EditorView.lineWrapping,
        EditorState.tabSize.of(tabSize),
        indentUnit.of(" ".repeat(tabSize)),
        errorLineField, // Add error line field
        keymap.of([
          {
            key: "Tab",
            preventDefault: true,
            run: (view) => {
              const tab = " ".repeat(tabSize)
              view.dispatch(view.state.replaceSelection(tab))
              return true
            },
            shift: (view) => {
              // Outdent logic (optional, can be improved)
              return false
            }
          }
        ]),
        EditorView.theme({
          "&": {
            height: "100%",
            fontSize: `${fontSize}px`,
            margin: 0,
            padding: 0,
            backgroundColor: actualTheme === "dracula" ? "#282a36" : 
                             isDarkTheme ? "#1e1e1e" : "white",
            color: actualTheme === "dracula" ? "#f8f8f2" : 
                   isDarkTheme ? "#d4d4d4" : "#333",
          },
          ".cm-scroller": {
            height: "100%",
            overflow: "auto",
            fontFamily: "'JetBrains Mono', monospace",
            padding: "0",
            /* VS Code scrollbar styling */
            "&::-webkit-scrollbar": {
              width: "8px",
              height: "8px",
            },
            "&::-webkit-scrollbar-track": {
              background: "transparent",
            },
            "&::-webkit-scrollbar-thumb": {
              background: isDarkTheme ? "rgba(150, 150, 150, 0.4)" : "rgba(100, 100, 100, 0.4)",
              borderRadius: "4px",
              "&:hover": {
                background: isDarkTheme ? "rgba(150, 150, 150, 0.7)" : "rgba(100, 100, 100, 0.7)",
              }
            },
            /* For Firefox */
            scrollbarWidth: "thin",
            scrollbarColor: isDarkTheme 
              ? "rgba(150, 150, 150, 0.4) transparent" 
              : "rgba(100, 100, 100, 0.4) transparent",
          },
          ".cm-gutters": {
            backgroundColor: actualTheme === "dracula" ? "#282a36" : 
                             isDarkTheme ? "#252526" : "#f8f9fa",
            color: actualTheme === "dracula" ? "#6272a4" :
                   isDarkTheme ? "#858585" : "#6c7086",
            border: "none",
            borderRight: actualTheme === "dracula" ? "1px solid #44475a" :
                          isDarkTheme ? "1px solid #333" : "1px solid #e5e7eb",
          },
          ".cm-activeLineGutter": {
            backgroundColor: actualTheme === "dracula" ? "#44475a" :
                              isDarkTheme ? "#2c2c2c" : "#f1f5f9",
          },
          ".cm-content": {
            padding: "0",
          },
          ".cm-line": {
            padding: "0 10px",
            lineHeight: "1.6",
          },
          ".cm-gutterElement": {
            padding: "0 10px 0 5px",
          },
          // Add Dracula theme specific styles if selected
          ...(actualTheme === "dracula" ? getDraculaTheme() : {})
        }),
      ],
    })

    const view = new EditorView({
      state,
      parent: element,
    })

    setEditor(view)
  }

  useEffect(() => {
    recreateEditor()

    return () => {
      if (editor) {
        editor.destroy()
      }
    }
  }, [element, language, mounted, setCode])

  // Update editor content when code prop changes (if different from current)
  useEffect(() => {
    // Only update the editor if the code prop changes from outside
    // and the user is not currently typing
    if (editor && 
        !isUserTyping.current && 
        lastDocContent.current !== code) {
      lastDocContent.current = code
      editor.dispatch({
        changes: {
          from: 0,
          to: editor.state.doc.length,
          insert: code,
        },
      })
    }
  }, [code, editor])
  
  // Handle error line highlighting
  useEffect(() => {
    if (!editor) return;
    
    // Debugging helper to log DOM structure
    const logEditorStructure = () => {
      try {
        const editorDOM = editor.dom;
        if (!editorDOM) {
          console.log("Editor DOM not available");
          return;
        }
        
        // Log the structure of lines and gutters
        const lines = editorDOM.querySelectorAll('.cm-line');
        const gutters = editorDOM.querySelectorAll('.cm-gutterElement');
        
        console.log(`Editor DOM structure: ${lines.length} lines, ${gutters.length} gutters`);
        console.log(`Target error line: ${errorLine}`);
        
        // Log the structure of the first few lines to help debug
        for (let i = 0; i < Math.min(5, lines.length); i++) {
          const lineEl = lines[i];
          console.log(`Line ${i+1}:`, lineEl.textContent?.substring(0, 20) + '...');
        }
      } catch (e) {
        console.error("Error logging editor structure:", e);
      }
    };
    
    // Function to clear all error highlights
    const clearAllErrorHighlights = () => {
      // Remove all existing error highlights
      document.querySelectorAll('.error-highlighted').forEach(el => {
        el.classList.remove('error-highlighted');
      });
      
      // Remove all existing error gutter highlights
      document.querySelectorAll('.error-gutter').forEach(el => {
        el.classList.remove('error-gutter');
      });
      
      // Remove any error markers
      document.querySelectorAll('.error-marker').forEach(el => {
        el.remove();
      });
    };
    
    // Clear existing highlights first
    clearAllErrorHighlights();
    
    // Also clear any decorations via the state field
    editor.dispatch({
      effects: clearErrorLines.of(null)
    });
    
    // If no error line, we're done
    if (errorLine === null || errorLine <= 0) {
      return;
    }
    
    console.log("Highlighting error line:", errorLine);
    
    // Create a function to apply the highlighting
    const applyHighlighting = () => {
      try {
        // Log editor structure to help debug
        logEditorStructure();
        
        // Get all line elements
        const lineElements = document.querySelectorAll('.cm-line');
        
        // Check if we have enough elements
        if (lineElements.length < errorLine) {
          console.warn(`Not enough line elements (${lineElements.length}) for error line ${errorLine}`);
          return;
        }
        
        // Get the target line
        const targetLine = lineElements[errorLine - 1];
        
        // Apply error highlighting to the line
        if (targetLine) {
          console.log(`Highlighting line ${errorLine}`);
          targetLine.classList.add('error-highlighted');
          
          // Find the fold gutter corresponding to this line
          // We need to find the gutter at the same vertical position
          const foldGutterElements = document.querySelectorAll('.cm-gutter.cm-foldGutter .cm-gutterElement');
          let foldGutterElement = null;
          
          // Get the position of the target line
          const lineRect = targetLine.getBoundingClientRect();
          
          // Find the fold gutter element that aligns with our target line
          for (let i = 0; i < foldGutterElements.length; i++) {
            const gutterEl = foldGutterElements[i];
            const gutterRect = gutterEl.getBoundingClientRect();
            
            // Check if this gutter element aligns with our target line
            // We check if the vertical center of the gutter is within the line's vertical range
            const gutterMiddle = gutterRect.top + (gutterRect.height / 2);
            if (gutterMiddle >= lineRect.top && gutterMiddle <= lineRect.bottom) {
              foldGutterElement = gutterEl;
              break;
            }
          }
          
          // If we found a matching fold gutter element, add the error marker
          if (foldGutterElement) {
            console.log(`Found matching fold gutter for line ${errorLine}`);
            
            // Create the error marker
            const marker = document.createElement('div');
            marker.className = 'error-marker';
            marker.textContent = '!';
            
            // Position the marker absolutely
            if (foldGutterElement instanceof HTMLElement) {
              foldGutterElement.style.position = 'relative';
              
              // Add the marker to the fold gutter
              foldGutterElement.appendChild(marker);
            }
          } else {
            console.warn(`Couldn't find matching fold gutter for line ${errorLine}`);
          }
        } else {
          console.warn(`Couldn't find element for line ${errorLine}`);
        }
      } catch (e) {
        console.error('Error applying highlighting:', e);
      }
    };
    
    // First scroll to the error line
    const doc = editor.state.doc;
    if (errorLine <= doc.lines) {
      const linePos = doc.line(errorLine).from;
      
      // Scroll to the line
      editor.dispatch({
        effects: EditorView.scrollIntoView(linePos, { y: 'center' })
      });
      
      // Wait a bit for the editor to render, then apply the highlighting
        setTimeout(() => {
          // Force editor to redraw first
          editor.requestMeasure();
          
          // Then wait a bit more for the DOM to fully update
          setTimeout(() => {
            console.log("Applying error highlighting...");
            applyHighlighting();
          }, 50);
        }, 150);
    }
  }, [errorLine, editor]);

  // Expose showSettings function through ref
  React.useEffect(() => {
    if (editorSettingsRef) {
      editorSettingsRef.current = {
        showSettings: () => setShowSettings(true)
      }
    }
  }, [editorSettingsRef])

  // Initialize settings state from props
  React.useEffect(() => {
    if (initialShowSettings) {
      setShowSettings(true)
    }
  }, [initialShowSettings])

  // Settings panel component
  const EditorSettings = () => {
    // Use portal for external trigger to ensure proper positioning
    if (editorSettingsRef && typeof window !== 'undefined') {
      return createPortal(
        <div 
          className={`fixed inset-0 z-[9999] flex items-start justify-center ${showSettings ? '' : 'pointer-events-none opacity-0'}`}
          onClick={(e) => {
            // Close when clicking the backdrop
            if (e.target === e.currentTarget) {
              setShowSettings(false);
              // Always reset state so it can be opened again
              setTimeout(() => setShowSettings(false), 10);
            }
          }}
        >
          {showSettings && (
            <div 
              className="absolute top-[60px] right-[80px] w-80 bg-background border border-border rounded-md shadow-lg"
              onClick={(e) => e.stopPropagation()}
            >
              <div className="p-3 font-medium border-b">Editor Settings</div>
              <div className="p-4 space-y-4">
                {/* Tab Size Setting */}
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <label className="text-sm font-medium">Tab Size</label>
                    <div className="flex items-center space-x-1">
                      {[2, 4, 8].map((size) => (
                        <Button
                          key={size}
                          variant={tabSize === size ? "default" : "outline"} 
                          size="sm"
                          className="h-8 w-8"
                          onClick={() => setTabSize(size)}
                        >
                          {size}
                        </Button>
                      ))}
                    </div>
                  </div>
                </div>
                
                {/* Font Size Setting */}
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <label className="text-sm font-medium">Font Size</label>
                    <div className="flex items-center space-x-1">
                      <Button
                        variant="outline" 
                        size="sm"
                        className="h-8 w-8"
                        onClick={() => setFontSize(Math.max(12, fontSize - 1))}
                        disabled={fontSize <= 12}
                      >
                        <Minus className="h-3 w-3" />
                      </Button>
                      <span className="w-8 text-center">{fontSize}</span>
                      <Button
                        variant="outline" 
                        size="sm"
                        className="h-8 w-8"
                        onClick={() => setFontSize(Math.min(24, fontSize + 1))}
                        disabled={fontSize >= 24}
                      >
                        <Plus className="h-3 w-3" />
                      </Button>
                    </div>
                  </div>
                </div>
                
                {/* Theme Setting */}
                <div className="space-y-2">
                  <label className="text-sm font-medium">Editor Theme</label>
                  <div className="grid grid-cols-2 gap-2">
                    {Object.entries(editorThemes).map(([key, label]) => (
                      <Button
                        key={key}
                        variant={editorTheme === key ? "default" : "outline"}
                        size="sm"
                        className="justify-start h-9"
                        onClick={() => setEditorTheme(key)}
                      >
                        {label}
                        {editorTheme === key && <Check className="ml-auto h-4 w-4" />}
                      </Button>
                    ))}
                  </div>
                </div>
                
                <Separator />
                
                {/* Reset Code */}
                <Button 
                  variant="outline" 
                  className="w-full"
                  onClick={handleResetCode}
                  disabled={!preloadCode}
                >
                  <RefreshCw className="mr-2 h-4 w-4" />
                  Reset Code
                </Button>
              </div>
            </div>
          )}
        </div>,
        document.body
      );
    }

    // For internal trigger (button inside editor)
    return (
      <Popover 
        open={showSettings} 
        onOpenChange={(open) => {
          if (!open) setShowSettings(false);
        }}
      >
        <PopoverTrigger asChild>
          <Button 
            variant="ghost" 
            size="icon" 
            className="absolute top-2 right-2 z-10 h-8 w-8 rounded-md bg-background/80 backdrop-blur"
          >
            <Settings className="h-4 w-4" />
          </Button>
        </PopoverTrigger>
        <PopoverContent 
          className="w-80 p-0" 
          align="end" 
          sideOffset={5}
          side="bottom"
          avoidCollisions={true}
        >
          <div className="p-3 font-medium border-b">Editor Settings</div>
          <div className="p-4 space-y-4">
            {/* Tab Size Setting */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <label className="text-sm font-medium">Tab Size</label>
                <div className="flex items-center space-x-1">
                  {[2, 4, 8].map((size) => (
                    <Button
                      key={size}
                      variant={tabSize === size ? "default" : "outline"} 
                      size="sm"
                      className="h-8 w-8"
                      onClick={() => setTabSize(size)}
                    >
                      {size}
                    </Button>
                  ))}
                </div>
              </div>
            </div>
            
            {/* Font Size Setting */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <label className="text-sm font-medium">Font Size</label>
                <div className="flex items-center space-x-1">
                  <Button
                    variant="outline" 
                    size="sm"
                    className="h-8 w-8"
                    onClick={() => setFontSize(Math.max(12, fontSize - 1))}
                    disabled={fontSize <= 12}
                  >
                    <Minus className="h-3 w-3" />
                  </Button>
                  <span className="w-8 text-center">{fontSize}</span>
                  <Button
                    variant="outline" 
                    size="sm"
                    className="h-8 w-8"
                    onClick={() => setFontSize(Math.min(24, fontSize + 1))}
                    disabled={fontSize >= 24}
                  >
                    <Plus className="h-3 w-3" />
                  </Button>
                </div>
              </div>
            </div>
            
            {/* Theme Setting */}
            <div className="space-y-2">
              <label className="text-sm font-medium">Editor Theme</label>
              <div className="grid grid-cols-2 gap-2">
                {Object.entries(editorThemes).map(([key, label]) => (
                  <Button
                    key={key}
                    variant={editorTheme === key ? "default" : "outline"}
                    size="sm"
                    className="justify-start h-9"
                    onClick={() => setEditorTheme(key)}
                  >
                    {label}
                    {editorTheme === key && <Check className="ml-auto h-4 w-4" />}
                  </Button>
                ))}
              </div>
            </div>
            
            <Separator />
            
            {/* Reset Code */}
            <Button 
              variant="outline" 
              className="w-full"
              onClick={handleResetCode}
              disabled={!preloadCode}
            >
              <RefreshCw className="mr-2 h-4 w-4" />
              Reset Code
            </Button>
          </div>
        </PopoverContent>
      </Popover>
    );
  };

  // Use consistent styling for server and client render
  return (
    <div className="relative w-full h-full">
      <EditorSettings />
      <div 
        ref={setElement} 
        className="w-full editor-container"
        style={{ 
          height: "100%", 
          overflow: "hidden",
          display: "flex", 
          flexDirection: "column",
          borderRadius: "6px",
          padding: 0,
          margin: 0,
        }}
      />
      <style jsx global>{`
        /* Error line styling */
        .cm-line.error-highlighted {
          background-color: rgba(255, 0, 0, 0.15) !important;
        }
        
        /* Style the gutter element */
        .cm-gutterElement.error-gutter {
          color: #ff0000 !important;
          font-weight: bold !important;
          position: relative !important;
        }
        
        /* Style the error marker in the gutter */
        .error-marker {
          position: absolute !important;
          left: 50% !important;
          top: 50% !important;
          transform: translate(-50%, -50%) !important;
          width: 14px !important;
          height: 14px !important;
          background-color: #ff0000 !important;
          color: white !important;
          border-radius: 50% !important;
          display: flex !important;
          justify-content: center !important;
          align-items: center !important;
          font-size: 10px !important;
          font-weight: bold !important;
          z-index: 1000 !important;
          box-shadow: 0px 0px 3px rgba(0,0,0,0.3) !important;
          pointer-events: none !important;
        }
      `}</style>
    </div>
  )
}
